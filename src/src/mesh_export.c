#include "sylves/mesh_export.h"
#include "sylves/matrix.h"
#include "sylves/errors.h"
#include "sylves/vector.h"
#include "sylves/utils.h"
#include "sylves/cell.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

SylvesError sylves_mesh_export_options_init(SylvesMeshExportOptions* options) {
    if (!options) return SYLVES_ERROR_INVALID_ARGUMENT;

    options->include_normals = 1;
    options->include_uvs = 1;
    options->include_colors = 0;
    options->binary_format = 0;
    options->material_name = "default";
    options->material_file = NULL;
    options->transform = sylves_matrix4x4_identity();
    options->float_precision = 6;

    return SYLVES_SUCCESS;
}

SylvesError sylves_export_mesh_data_to_stream(
    const SylvesMeshDataEx* mesh,
    FILE* file,
    SylvesMeshFormat format,
    const SylvesMeshExportOptions* options
) {
    if (!mesh || !file || !options) return SYLVES_ERROR_INVALID_ARGUMENT;

    switch (format) {
        case SYLVES_MESH_FORMAT_OBJ:
            return sylves_export_obj(mesh, file, options);
        case SYLVES_MESH_FORMAT_PLY:
            return sylves_export_ply(mesh, file, options);
        case SYLVES_MESH_FORMAT_STL:
            return sylves_export_stl(mesh, file, options);
        case SYLVES_MESH_FORMAT_OFF:
            return sylves_export_off(mesh, file, options);
        default:
            return SYLVES_ERROR_INVALID_ARGUMENT;
    }
}

SylvesError sylves_export_grid_mesh(
    const SylvesGrid* grid,
    const char* filename,
    SylvesMeshFormat format,
    const SylvesMeshExportOptions* options
) {
    if (!grid || !filename || !options) return SYLVES_ERROR_INVALID_ARGUMENT;

    // Convert grid to mesh data
    SylvesMeshData* simple = NULL;
    SylvesError err = sylves_grid_get_mesh_data(grid, sylves_cell_create(0,0,0), &simple);
    if (err != SYLVES_SUCCESS) {
        return err;
    }
    SylvesMeshDataEx* mesh = sylves_mesh_data_to_ex(simple);
    sylves_mesh_data_free(simple);

    // Export the mesh
    err = sylves_export_mesh_data(mesh, filename, format, options);

    // Clean up
    sylves_mesh_data_ex_destroy(mesh);

    return err;
}

SylvesError sylves_export_obj_material(
    const char* filename,
    const char* material_name,
    const SylvesVector3* diffuse_color,
    const SylvesVector3* specular_color,
    float shininess
) {
    if (!filename || !material_name) return SYLVES_ERROR_INVALID_ARGUMENT;

    FILE* file = fopen(filename, "w");
    if (!file) return SYLVES_ERROR_IO;

    fprintf(file, "# Material file generated by Sylves\n");
    fprintf(file, "newmtl %s\n", material_name);
    
    if (diffuse_color) {
        fprintf(file, "Kd %.6f %.6f %.6f\n", diffuse_color->x, diffuse_color->y, diffuse_color->z);
    } else {
        fprintf(file, "Kd 0.8 0.8 0.8\n");
    }
    
    if (specular_color) {
        fprintf(file, "Ks %.6f %.6f %.6f\n", specular_color->x, specular_color->y, specular_color->z);
    } else {
        fprintf(file, "Ks 0.5 0.5 0.5\n");
    }
    
    fprintf(file, "Ka 0.2 0.2 0.2\n"); // Ambient
    fprintf(file, "Ns %.1f\n", shininess);
    fprintf(file, "Ni 1.0\n"); // Optical density
    fprintf(file, "d 1.0\n");  // Dissolve (opacity)
    fprintf(file, "illum 2\n"); // Illumination model

    fclose(file);
    return SYLVES_SUCCESS;
}

SylvesError sylves_export_mesh_data(
    const SylvesMeshDataEx* mesh,
    const char* filename,
    SylvesMeshFormat format,
    const SylvesMeshExportOptions* options
) {
    if (!mesh || !filename || !options) return SYLVES_ERROR_INVALID_ARGUMENT;

    FILE* file = fopen(filename, "w");
    if (!file) return SYLVES_ERROR_IO;

    SylvesError err;
    switch (format) {
        case SYLVES_MESH_FORMAT_OBJ:
            err = sylves_export_obj(mesh, file, options);
            break;
        case SYLVES_MESH_FORMAT_PLY:
            err = sylves_export_ply(mesh, file, options);
            break;
        case SYLVES_MESH_FORMAT_STL:
            err = sylves_export_stl(mesh, file, options);
            break;
        case SYLVES_MESH_FORMAT_OFF:
            err = sylves_export_off(mesh, file, options);
            break;
        default:
            err = SYLVES_ERROR_INVALID_ARGUMENT;
    }

    fclose(file);
    return err;
}

SylvesError sylves_export_obj(
    const SylvesMeshDataEx* mesh,
    FILE* file,
    const SylvesMeshExportOptions* options
) {
    if (!mesh || !file || !options) return SYLVES_ERROR_INVALID_ARGUMENT;

    // Write header comment
    fprintf(file, "# Exported by Sylves\n");
    fprintf(file, "# Vertices: %zu\n", mesh->vertex_count);
    
    // Optional material file reference
    if (options->material_file) {
        fprintf(file, "mtllib %s\n", options->material_file);
    }

    // Write vertices
    for (size_t i = 0; i < mesh->vertex_count; i++) {
        SylvesVector3 v = mesh->vertices[i];
        v = sylves_matrix4x4_multiply_point(&options->transform, v);
        fprintf(file, "v %.*f %.*f %.*f\n", 
            options->float_precision, v.x,
            options->float_precision, v.y,
            options->float_precision, v.z);
    }

    // Write texture coordinates
    if (options->include_uvs && mesh->uvs) {
        for (size_t i = 0; i < mesh->vertex_count; i++) {
            fprintf(file, "vt %.*f %.*f\n",
                options->float_precision, mesh->uvs[i].x,
                options->float_precision, mesh->uvs[i].y);
        }
    }

    // Write normals
    if (options->include_normals && mesh->normals) {
        for (size_t i = 0; i < mesh->vertex_count; i++) {
            SylvesVector3 n = mesh->normals[i];
            // Transform normal (rotation only, no translation)
            n = sylves_matrix4x4_multiply_vector(&options->transform, n);
            n = sylves_vector3_normalize(n);
            fprintf(file, "vn %.*f %.*f %.*f\n",
                options->float_precision, n.x,
                options->float_precision, n.y,
                options->float_precision, n.z);
        }
    }

    // Use material if specified
    if (options->material_name) {
        fprintf(file, "usemtl %s\n", options->material_name);
    }

    // Write faces
    for (size_t s = 0; s < mesh->submesh_count; s++) {
        const SylvesSubmesh* submesh = &mesh->submeshes[s];
        
        if (submesh->topology == SYLVES_MESH_TOPOLOGY_TRIANGLES) {
            for (size_t i = 0; i < submesh->index_count; i += 3) {
                int i0 = submesh->indices[i] + 1;
                int i1 = submesh->indices[i + 1] + 1;
                int i2 = submesh->indices[i + 2] + 1;
                
                if (options->include_normals && options->include_uvs) {
                    fprintf(file, "f %d/%d/%d %d/%d/%d %d/%d/%d\n",
                        i0, i0, i0, i1, i1, i1, i2, i2, i2);
                } else if (options->include_uvs) {
                    fprintf(file, "f %d/%d %d/%d %d/%d\n",
                        i0, i0, i1, i1, i2, i2);
                } else if (options->include_normals) {
                    fprintf(file, "f %d//%d %d//%d %d//%d\n",
                        i0, i0, i1, i1, i2, i2);
                } else {
                    fprintf(file, "f %d %d %d\n", i0, i1, i2);
                }
            }
        } else if (submesh->topology == SYLVES_MESH_TOPOLOGY_QUADS) {
            for (size_t i = 0; i < submesh->index_count; i += 4) {
                int i0 = submesh->indices[i] + 1;
                int i1 = submesh->indices[i + 1] + 1;
                int i2 = submesh->indices[i + 2] + 1;
                int i3 = submesh->indices[i + 3] + 1;
                
                if (options->include_normals && options->include_uvs) {
                    fprintf(file, "f %d/%d/%d %d/%d/%d %d/%d/%d %d/%d/%d\n",
                        i0, i0, i0, i1, i1, i1, i2, i2, i2, i3, i3, i3);
                } else {
                    fprintf(file, "f %d %d %d %d\n", i0, i1, i2, i3);
                }
            }
        }
    }

    return SYLVES_SUCCESS;
}

// PLY, STL, and OFF formats omitted for brevity

SylvesError sylves_export_ply(
    const SylvesMeshDataEx* mesh,
    FILE* file,
    const SylvesMeshExportOptions* options
) {
    if (!mesh || !file || !options) return SYLVES_ERROR_INVALID_ARGUMENT;

    // Count triangles
    size_t triangle_count = 0;
    for (size_t i = 0; i < mesh->submesh_count; i++) {
        if (mesh->submeshes[i].topology == SYLVES_MESH_TOPOLOGY_TRIANGLES) {
            triangle_count += mesh->submeshes[i].index_count / 3;
        } else if (mesh->submeshes[i].topology == SYLVES_MESH_TOPOLOGY_QUADS) {
            triangle_count += (mesh->submeshes[i].index_count / 4) * 2; // Split quads
        }
    }

    // Write PLY header
    fprintf(file, "ply\n");
    fprintf(file, "format ascii 1.0\n");
    fprintf(file, "comment Exported by Sylves\n");
    fprintf(file, "element vertex %zu\n", mesh->vertex_count);
    fprintf(file, "property float x\n");
    fprintf(file, "property float y\n");
    fprintf(file, "property float z\n");
    
    if (options->include_normals && mesh->normals) {
        fprintf(file, "property float nx\n");
        fprintf(file, "property float ny\n");
        fprintf(file, "property float nz\n");
    }
    
    if (options->include_uvs && mesh->uvs) {
        fprintf(file, "property float s\n");
        fprintf(file, "property float t\n");
    }
    
    fprintf(file, "element face %zu\n", triangle_count);
    fprintf(file, "property list uchar int vertex_indices\n");
    fprintf(file, "end_header\n");

    // Write vertices
    for (size_t i = 0; i < mesh->vertex_count; i++) {
        SylvesVector3 v = mesh->vertices[i];
        v = sylves_matrix4x4_multiply_point(&options->transform, v);
        fprintf(file, "%.*f %.*f %.*f",
            options->float_precision, v.x,
            options->float_precision, v.y,
            options->float_precision, v.z);
            
        if (options->include_normals && mesh->normals) {
            SylvesVector3 n = mesh->normals[i];
            n = sylves_matrix4x4_multiply_vector(&options->transform, n);
            n = sylves_vector3_normalize(n);
            fprintf(file, " %.*f %.*f %.*f",
                options->float_precision, n.x,
                options->float_precision, n.y,
                options->float_precision, n.z);
        }
        
        if (options->include_uvs && mesh->uvs) {
            fprintf(file, " %.*f %.*f",
                options->float_precision, mesh->uvs[i].x,
                options->float_precision, mesh->uvs[i].y);
        }
        
        fprintf(file, "\n");
    }

    // Write faces
    for (size_t s = 0; s < mesh->submesh_count; s++) {
        const SylvesSubmesh* submesh = &mesh->submeshes[s];
        
        if (submesh->topology == SYLVES_MESH_TOPOLOGY_TRIANGLES) {
            for (size_t i = 0; i < submesh->index_count; i += 3) {
                fprintf(file, "3 %d %d %d\n",
                    submesh->indices[i],
                    submesh->indices[i + 1],
                    submesh->indices[i + 2]);
            }
        } else if (submesh->topology == SYLVES_MESH_TOPOLOGY_QUADS) {
            // Split quads into triangles
            for (size_t i = 0; i < submesh->index_count; i += 4) {
                fprintf(file, "3 %d %d %d\n",
                    submesh->indices[i],
                    submesh->indices[i + 1],
                    submesh->indices[i + 2]);
                fprintf(file, "3 %d %d %d\n",
                    submesh->indices[i],
                    submesh->indices[i + 2],
                    submesh->indices[i + 3]);
            }
        }
    }

    return SYLVES_SUCCESS;
}

SylvesError sylves_export_stl(
    const SylvesMeshDataEx* mesh,
    FILE* file,
    const SylvesMeshExportOptions* options
) {
    if (!mesh || !file || !options) return SYLVES_ERROR_INVALID_ARGUMENT;

    if (options->binary_format) {
        // Binary STL not implemented in this basic version
        return SYLVES_ERROR_NOT_IMPLEMENTED;
    }

    // ASCII STL
    fprintf(file, "solid Exported_by_Sylves\n");

    // Export triangles
    for (size_t s = 0; s < mesh->submesh_count; s++) {
        const SylvesSubmesh* submesh = &mesh->submeshes[s];
        
        if (submesh->topology == SYLVES_MESH_TOPOLOGY_TRIANGLES) {
            for (size_t i = 0; i < submesh->index_count; i += 3) {
                SylvesVector3 v0 = mesh->vertices[submesh->indices[i]];
                SylvesVector3 v1 = mesh->vertices[submesh->indices[i + 1]];
                SylvesVector3 v2 = mesh->vertices[submesh->indices[i + 2]];
                
                // Transform vertices
                v0 = sylves_matrix4x4_multiply_point(&options->transform, v0);
                v1 = sylves_matrix4x4_multiply_point(&options->transform, v1);
                v2 = sylves_matrix4x4_multiply_point(&options->transform, v2);
                
                // Calculate normal
                SylvesVector3 edge1 = sylves_vector3_subtract(v1, v0);
                SylvesVector3 edge2 = sylves_vector3_subtract(v2, v0);
                SylvesVector3 normal = sylves_vector3_cross(edge1, edge2);
                normal = sylves_vector3_normalize(normal);
                
                fprintf(file, "  facet normal %e %e %e\n", normal.x, normal.y, normal.z);
                fprintf(file, "    outer loop\n");
                fprintf(file, "      vertex %e %e %e\n", v0.x, v0.y, v0.z);
                fprintf(file, "      vertex %e %e %e\n", v1.x, v1.y, v1.z);
                fprintf(file, "      vertex %e %e %e\n", v2.x, v2.y, v2.z);
                fprintf(file, "    endloop\n");
                fprintf(file, "  endfacet\n");
            }
        } else if (submesh->topology == SYLVES_MESH_TOPOLOGY_QUADS) {
            // Split quads into triangles
            for (size_t i = 0; i < submesh->index_count; i += 4) {
                // First triangle
                SylvesVector3 v0 = mesh->vertices[submesh->indices[i]];
                SylvesVector3 v1 = mesh->vertices[submesh->indices[i + 1]];
                SylvesVector3 v2 = mesh->vertices[submesh->indices[i + 2]];
                SylvesVector3 v3 = mesh->vertices[submesh->indices[i + 3]];
                
                // Transform vertices
                v0 = sylves_matrix4x4_multiply_point(&options->transform, v0);
                v1 = sylves_matrix4x4_multiply_point(&options->transform, v1);
                v2 = sylves_matrix4x4_multiply_point(&options->transform, v2);
                v3 = sylves_matrix4x4_multiply_point(&options->transform, v3);
                
                // First triangle (0,1,2)
                SylvesVector3 edge1 = sylves_vector3_subtract(v1, v0);
                SylvesVector3 edge2 = sylves_vector3_subtract(v2, v0);
                SylvesVector3 normal = sylves_vector3_cross(edge1, edge2);
                normal = sylves_vector3_normalize(normal);
                
                fprintf(file, "  facet normal %e %e %e\n", normal.x, normal.y, normal.z);
                fprintf(file, "    outer loop\n");
                fprintf(file, "      vertex %e %e %e\n", v0.x, v0.y, v0.z);
                fprintf(file, "      vertex %e %e %e\n", v1.x, v1.y, v1.z);
                fprintf(file, "      vertex %e %e %e\n", v2.x, v2.y, v2.z);
                fprintf(file, "    endloop\n");
                fprintf(file, "  endfacet\n");
                
                // Second triangle (0,2,3)
                edge1 = sylves_vector3_subtract(v2, v0);
                edge2 = sylves_vector3_subtract(v3, v0);
                normal = sylves_vector3_cross(edge1, edge2);
                normal = sylves_vector3_normalize(normal);
                
                fprintf(file, "  facet normal %e %e %e\n", normal.x, normal.y, normal.z);
                fprintf(file, "    outer loop\n");
                fprintf(file, "      vertex %e %e %e\n", v0.x, v0.y, v0.z);
                fprintf(file, "      vertex %e %e %e\n", v2.x, v2.y, v2.z);
                fprintf(file, "      vertex %e %e %e\n", v3.x, v3.y, v3.z);
                fprintf(file, "    endloop\n");
                fprintf(file, "  endfacet\n");
            }
        }
    }

    fprintf(file, "endsolid Exported_by_Sylves\n");
    return SYLVES_SUCCESS;
}

SylvesError sylves_export_off(
    const SylvesMeshDataEx* mesh,
    FILE* file,
    const SylvesMeshExportOptions* options
) {
    if (!mesh || !file || !options) return SYLVES_ERROR_INVALID_ARGUMENT;

    // Count faces and edges
    size_t face_count = 0;
    size_t edge_count = 0; // Approximate
    
    for (size_t i = 0; i < mesh->submesh_count; i++) {
        if (mesh->submeshes[i].topology == SYLVES_MESH_TOPOLOGY_TRIANGLES) {
            face_count += mesh->submeshes[i].index_count / 3;
            edge_count += mesh->submeshes[i].index_count; // Overestimate
        } else if (mesh->submeshes[i].topology == SYLVES_MESH_TOPOLOGY_QUADS) {
            face_count += mesh->submeshes[i].index_count / 4;
            edge_count += mesh->submeshes[i].index_count; // Overestimate
        }
    }

    // Write OFF header
    fprintf(file, "OFF\n");
    fprintf(file, "%zu %zu %zu\n", mesh->vertex_count, face_count, edge_count);

    // Write vertices
    for (size_t i = 0; i < mesh->vertex_count; i++) {
        SylvesVector3 v = mesh->vertices[i];
        v = sylves_matrix4x4_multiply_point(&options->transform, v);
        fprintf(file, "%.*f %.*f %.*f\n",
            options->float_precision, v.x,
            options->float_precision, v.y,
            options->float_precision, v.z);
    }

    // Write faces
    for (size_t s = 0; s < mesh->submesh_count; s++) {
        const SylvesSubmesh* submesh = &mesh->submeshes[s];
        
        if (submesh->topology == SYLVES_MESH_TOPOLOGY_TRIANGLES) {
            for (size_t i = 0; i < submesh->index_count; i += 3) {
                fprintf(file, "3 %d %d %d\n",
                    submesh->indices[i],
                    submesh->indices[i + 1],
                    submesh->indices[i + 2]);
            }
        } else if (submesh->topology == SYLVES_MESH_TOPOLOGY_QUADS) {
            for (size_t i = 0; i < submesh->index_count; i += 4) {
                fprintf(file, "4 %d %d %d %d\n",
                    submesh->indices[i],
                    submesh->indices[i + 1],
                    submesh->indices[i + 2],
                    submesh->indices[i + 3]);
            }
        }
    }

    return SYLVES_SUCCESS;
}
